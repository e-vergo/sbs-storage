# Extend Declaration Type Support (#342)

## Context

The Dress toolchain only treats 5 declaration types as first-class: `def`, `theorem`, `axiom`, `opaque`, `inductive`. Structures, classes, instances, and abbrevs are partially supported (graph shapes work, `@[blueprint]` works) but are misclassified in coverage tracking (`structure` reports as "inductive", `instance`/`abbrev` report as "def") and lack auto-detection of their `latexEnv` type.

This blocks self-documentation of Dress and Runway, which use these declaration types extensively.

## API Availability (Verified)

Lean v4.28.0-rc1 (pinned in Dress). All APIs available via existing `import Lean` + `open Lean Meta`:

| API | Signature | Detects |
|-----|-----------|---------|
| `Lean.isClass` | `env → name → Bool` | class vs structure |
| `Lean.isStructure` | `env → name → Bool` | structure vs plain inductive |
| `Lean.Meta.isInstanceCore` | `env → name → Bool` | typeclass instance |
| `DefinitionVal.hints.isAbbrev` | `Bool` (on `.defnInfo dv`) | abbrev vs plain def |

## Changes

### 1. `Dress/Graph/Build.lean` (3 edits)

**a) `constantKind` (L434-442)** — change signature to `(env : Environment) → (name : Name) → (ci : ConstantInfo) → String`

```lean
private def constantKind (env : Lean.Environment) (name : Lean.Name) (ci : Lean.ConstantInfo) : String :=
  match ci with
  | .defnInfo dv =>
    if Lean.Meta.isInstanceCore env name then "instance"
    else if dv.hints.isAbbrev then "abbrev"
    else "def"
  | .thmInfo _    => "theorem"
  | .axiomInfo _  => "axiom"
  | .opaqueInfo _ => "opaque"
  | .inductInfo _ =>
    if Lean.isClass env name then "class"
    else if Lean.isStructure env name then "structure"
    else "inductive"
  | _             => "other"
```

**b) `computeCoverage` call site (L478)** — pass `env` and `name`:
```lean
kind := constantKind env name ci  -- was: constantKind ci
```

**c) Extend axiom-override pattern (after L404)** — auto-detect `latexEnv` for graph `envType`:
```lean
-- After the existing axiom detection block:
| some (.inductInfo _) =>
  let kind := if Lean.isClass env node.name then "class"
    else if Lean.isStructure env node.name then "structure"
    else none
  if let some k := kind then
    let updatedStatement := { dressNode.toNode.statement with latexEnv := k }
    let updatedNode := { dressNode.toNode with statement := updatedStatement }
    dressNode := { dressNode with toNode := updatedNode }
| some (.defnInfo dv) =>
  let kind := if Lean.Meta.isInstanceCore env node.name then some "instance"
    else if dv.hints.isAbbrev then some "abbrev"
    else none
  if let some k := kind then
    let updatedStatement := { dressNode.toNode.statement with latexEnv := k }
    let updatedNode := { dressNode.toNode with statement := updatedStatement }
    dressNode := { dressNode with toNode := updatedNode }
```

### 2. `Dress/Generate/Latex.lean` (L36-46)

**`getDefaultLatexEnv`** — add sub-classification:

```lean
def getDefaultLatexEnv (name : Name) : CommandElabM String := do
  let env ← getEnv
  let some info := env.find? name | return "theorem"
  match info with
  | .thmInfo _ => return "theorem"
  | .defnInfo dv =>
    if Meta.isInstanceCore env name then return "instance"
    else if dv.hints.isAbbrev then return "abbrev"
    else return "definition"
  | .opaqueInfo _ => return "definition"
  | .inductInfo _ =>
    if isClass env name then return "class"
    else if isStructure env name then return "structure"
    else return "definition"
  | .ctorInfo _ => return "definition"
  | .recInfo _ => return "definition"
  | _ => return "theorem"
```

### 3. `LeanArchitect/Attribute.lean` (L275) — separate repo

Auto-detect default `latexEnv`:
```lean
-- Current:
latexEnv := cfg.latexEnv.getD (if hasProof then "theorem" else "definition")
-- New: query env when cfg.latexEnv is none
latexEnv := match cfg.latexEnv with
  | some e => e
  | none =>
    let env ← getEnv
    if hasProof then "theorem"
    else if isClass env name then "class"
    else if isStructure env name then "structure"
    else if Meta.isInstanceCore env name then "instance"
    else -- check abbrev via ConstantInfo
      match env.find? name with
      | some (.defnInfo dv) => if dv.hints.isAbbrev then "abbrev" else "definition"
      | _ => "definition"
```

Note: `mkStatementPart` is in `CoreM`, so `getEnv` is available.

## No Changes Needed

- **`isEligibleConstant`**: all 4 types already pass (`.inductInfo` and `.defnInfo` branches)
- **`isAutoGenerated`**: already filters `mk`, `rec`, `recOn`, `casesOn`, etc.
- **`isProjection`**: already catches structure projection functions
- **`getShape`**: already maps all 4 type strings → `.box`

## Execution

**Wave 1 — Implementation:** Single `sbs-developer` agent, all 3 files. Changes are small and tightly coupled.

**Wave 2 — Build + Verify:** Build SBS-Test via `./dev/build-sbs-test.sh`. Check `lean_diagnostic_messages`. Inspect coverage output for correct kind strings.

## Verification

1. `lean_diagnostic_messages` clean on both Dress and LeanArchitect
2. SBS-Test builds successfully end-to-end
3. Coverage uncovered list shows "structure"/"class"/"instance"/"abbrev" kind strings where applicable (instead of "inductive"/"def")
4. Evergreen pytest: `pytest sbs/tests/pytest -m evergreen --tb=short`

## Submodule Commit Order

1. LeanArchitect: commit + push
2. Dress: commit + push
3. SBS: update submodule pointers, commit + push
4. SLS: handled by `sls_update_and_archive`
