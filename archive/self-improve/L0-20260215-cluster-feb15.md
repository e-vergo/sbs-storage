# L0 Introspection Finding -- Feb 15, 2026 Session Cluster

## Session Context
- Level: L0
- Entries analyzed: 11 (IDs 1771137626 through 1771188388)
- Improvement captures analyzed: 1 (1771188388)
- Issues correlated: #284, #285, #287, #289, #290, #292, #295
- Issues logged: #344 (recursive sls_task reentry), #347 (cross-task tag leakage)

---

## Session Overview

Two task sessions ran on Feb 15, 2026, within the same Claude Code session:

| Session | Duration | Entries | Phases | Key Characteristic |
|---------|----------|---------|--------|--------------------|
| Task 1 | 01:40-12:44 (~11h) | 8 | alignment -> planning -> execution -> finalization | Extremely long, scope-expanded |
| Task 2 | 15:40-15:41 (~33s) | 3 | update-and-archive only | Clean porcelain |

Plus 1 improvement capture (1771188388) at 15:46.

## Findings

### 1. CRITICAL: Recursive sls_task reentry corrupts global_state

**Evidence:** Improvement capture 1771188388 reports that agents within a running task called `sls_task` again, re-entering the workflow and corrupting global_state tracking.

**Code verification:** `skill_tools.py` line 944 checks `if current_skill and current_skill != "task"` -- this deliberately allows reentry when current_skill is already "task". The guard was likely intended for crash recovery (resume a task after restart), but it permits nested invocation from agents.

**Impact chain:**
1. Agent spawned during task execution calls `sls_task(phase="start")`
2. Guard passes because `current_skill == "task"` makes `!= "task"` false
3. Substate overwrites from "execution" back to "alignment"
4. Nested task creates mixed archive entries
5. Nested task end clears global_state, orphaning the parent

**Fix:** Change the guard to block all reentry. Add explicit `resume=True` parameter if crash recovery is needed.

**Issue logged:** #344

### 2. Signal tags leak across task boundaries within a single Claude Code session

**Evidence:** Session 2 (entries 1771188038-1771188071) was a 33-second update-and-archive operation. It carries the full set of friction signals from Session 1:
- `signal:consecutive-bash-failures`
- `signal:same-command-retry`
- `signal:cli-misfire`
- `signal:retry-loop`
- `signal:high-churn`
- `signal:context-compaction`

A 33-second porcelain operation cannot generate "high churn" or "retry loops." These tags were inherited from the 11-hour Session 1 because the tagger evaluates the full Claude Code session transcript, not the epoch-scoped portion.

**Relationship to #287:** This is a concrete, testable instance of the general tagger granularity problem. #287 discusses within-epoch uniformity; this finding identifies specific cross-task-boundary leakage.

**Issue logged:** #347

### 3. 11-hour session validates #295's scope control concerns

Session 1 ran from 01:40 to 12:44 -- approximately 11 hours. This is the longest task session observed to date. Key signals:

- `outcome:scope-expanded` tagged on the execution entry (1771138089)
- 8 entries across 4 phases (alignment, planning, execution, finalization + update-and-archive)
- All entries carry `session:long`, `session:exploration-heavy`, `token:total-heavy`
- `signal:context-compaction` present on 100% of entries

The scope expansion during execution is particularly concerning: the task started narrow (`scope:narrow`) but expanded mid-flight. This is the exact failure mode #295 proposes to address with soft limits and automatic epoch boundaries.

**No new issue logged** -- this is additional evidence for #295.

### 4. oracle-first violation continues at 100%

All 11 entries carry `oracle-first:missed`. This is the third consecutive epoch with 100% oracle-first violation. The pattern is now persistent across:
- Feb 8 epoch (48 entries, L0-20260209000953.md)
- Feb 15 Session 1 (8 entries)
- Feb 15 Session 2 (3 entries)

This validates #285's assessment and strengthens the case for #292's graduation pipeline (moving oracle-first from Stage 1/documentation to Stage 3/tooling guardrail).

**No new issue logged** -- reinforces #285 and #292.

### 5. model:multi-model usage consistent

All entries show both `model:opus` and `model:sonnet` tags, indicating the orchestrator used Opus while spawned agents may have used Sonnet. This is expected behavior (the orchestrator runs Opus 4.6, agents may use different models). No issue here, but the pattern is worth tracking: if agent quality correlates with model choice, this could inform agent spawning policy.

## Actions Taken

- **#344 logged:** Recursive sls_task reentry bug with code-level fix direction
- **#347 logged:** Cross-task tag leakage with concrete evidence from this session
- **No additional issues:** Remaining findings reinforce existing open issues (#285, #287, #292, #295)

## Patterns Identified

1. **Scope expansion in long sessions:** The 11-hour session started narrow but expanded during execution. Long sessions correlate with scope drift.
2. **Cross-task tag contamination:** When multiple tasks share a Claude Code session, the tagger's session-level evaluation creates false signal attribution.
3. **Reentry vulnerability window:** The `sls_task` start phase allows same-skill reentry, which agents can exploit (intentionally or accidentally).
4. **Oracle-first is structurally unfollowed:** Three consecutive epochs with 100% violation. Documentation alone is demonstrably insufficient.

## Recommendations

1. **Fix #344 immediately:** The recursive reentry bug is a data integrity issue. The fix is a 3-line guard change in `skill_tools.py`. This should be high priority.
2. **Scope the tagger signal window (#347):** Reset signal evaluation at skill boundaries. This is a focused change to the tagger that would significantly improve archive data quality.
3. **Track session duration as a health metric:** The 11-hour session should trigger soft warnings. #295 proposes this; this finding provides the first concrete data point above the proposed 2-hour threshold.
4. **Graduate oracle-first to Stage 3 per #292:** Three epochs of 100% violation is conclusive evidence that documentation enforcement has failed.

## Cross-References

- Prior L0: L0-20260209000953.md, L0-20260209001854.md (Feb 8 epoch)
- Prior L1: L1-20260209002147.md (cross-session synthesis)
- Prior L2: L2-20260209002539.md (systemic patterns)
- Improvement capture: 1771188388 (recursive task call observation)
